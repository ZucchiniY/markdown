---
title: 通配符与正则
tags:
  - regex
  - wildcard
categories:
  - 工具环境
  - 正则表达式
description: 关于正则表达式与通配符的异同思考。
abbrlink: a3183791
date: 2018-05-20 07:27:00
---

## 简述 

通配符和正则表达式很容易混淆，首先二者所应用的对象是不同的，通配符主要是用在 **Shell** 命令中，比如 `find` 、 `ls` 、 `cp` 等，而正则是使用在文本过滤工具（可以是字符串搜索和替换等），例如 `awk` ， `sed` 等。

## 通配符 

[a-z] [...] : 匹配方括号中指定范围内的单个字符或方括号列出的其中一个字符
[!9] [!..] : 不匹配方括号中的字符或指定范围内的单个字符
\* : 匹配 0 个字符或多个字符
? : 匹配任何单个字符，且不能为空的字符

> 因为 **Shell** 会将方括号( `[` 、 `]` )、问号( `?` )、星号( `*` )等内容特殊处理，因此想匹配这几个字符时，需要加转义符 `\` 。

| 通配符号 | 内容                                      |
|----------|-------------------------------------------|
| *        | 万用字符，代表0个或者多个字符（包括数字） |
| ?        | 万用字符，代表一定有一个字符              |
| #        | 注解字符，常用在说明或者备注中            |
| \        | 转义字符，将特殊字符还原为一般字符        |
| &vert;   | 分隔字符，分隔两个管道命令                |
| ;        | 连续命令界定符，用来分隔                  |
| ~        | 登录用户的 home 路径                      |
| $        | 变量声明字符，用来表示变量                |
| &        | 后台执行命令                              |
| !        | 逻辑运算符非                              |
| > >>     | 输出导入符，一个为取代，两个为累加        |
| '        | 单引号，不具有变量转换功能                |
| "        | 具有变量转换功能                          |
| ``       | 中间为可以先执行的指令                    |
| ()       | 中间为子 shell 起始与结束                 |
| []       | 中间为字符组合                            |
| {}       | 中间为命令区块的组合                      |

## 正则表达式 

### 字符匹配 

. : 匹配任意单个字符
\* : 匹配其前面一个字符出现任意次
? : 匹配其前面的字符1次或者0次
\+ : 匹配其前面的字符至少出现1次（扩展正则表达式中）

### 位置匹配 

^ : 行首
$ : 行尾
\\< 或 \b : 词首，其后面的任意字符必须作为单词首部出现
\\> 或 \b : 词尾，其前面的任意字符必须作为单词尾部出现
\B : 非单词开头或结尾
^$ : 空白行

### 分组 

(ab)* : 匹配 **ab** 这个分组出现任意次
\1 : 引用第一个左括号以及与之对应的右括号所包括的内容
\n : 同 \1


### 特殊 

`[:alnum:]` : 任何字母和数字
`[:alpha:]` : 任何字母
`[:cntrl:]` : 控制字符，包括 **ASCII** 表中的 **000** - **037** 再加上 **177('DEL')**
`[:digit:]` : 任何数字
`[:punct:]` : 标点符号，`'!"#$%&()*-+,./:;<=>?@[]\\^_{|}~`
`[:graph:]` : 打印字符，等价于 `[:alnum:]` + `[:punct:]`
`[:lower:]` : 小字字母
`[:upper:]` : 大写字母
`[:print:]` : 可打印字符，等价于 `[:alnum:]` + `[punct:]` + `[:space:]`
`[:space:]` : 空白字符，包括 tab/newline/vertical tab/form feed/carriage return/space
`[:xdigit:]` : 任何16进制数字，相当于 [0-9a-fA-F]

> 1.  `^[[:space:]]*$` : 匹配没有任何内容的行
> 2.  [] : 中的特殊字符( **.** , ***** )会失去特殊含义

| 正则      | 意义                                                                                                   |
|-----------|--------------------------------------------------------------------------------------------------------|
| ^word     | 搜索在行首的字符串                                                                                     |
| word$     | 搜索在行尾的字符串                                                                                     |
| .         | 任意一个字符                                                                                           |
| \\       | 转义字符                                                                                               |
| \*      | 重复0个或者多个前一字符情况                                                                            |
| {n,m}     | 连续 n 到 m 个的前一个字符，若为 {n} 则是连续的 n 个前一个字符，若是 {n,} 则是连续 n 个以上的前一个字符|
| [list]    | 表示字符列表集合                                                                                       |
| [ch1-ch2] | 表示字符顺序列表                                                                                       |
| [^]       | 表示不包含字符                                                                                         |

### 使用正则进行匹配的示例

`grep -n '^#' temp.txt`:搜索到行首为 # 的那一行
`grep -n '!$' temp.txt`:搜索行尾为 ! 的那一行
`grep -n 'e.e' temp.txt`:搜索字符串可以是 eve ，eae ，e e ，但是不会是 ee
`grep -n ''' temp.txt`:搜索含有 ' 的那一行
`grep -n 'ess*' temp.txt`:找出有 es ， ess ， esss 的一行，因为 \* 是大于等0个，所以可以匹配 es
`grep -n 'go{2,3}g' temp.txt`:在 g 和 g 之间有 2 到 3 个 o 存在，即 goog ， gooog
`grep -n 'g[ld]' temp.txt`:搜索含有 gl 和 gd 的那一个，注意，这里只代表一个，如 [lad]f ，只有 glf ， gaf 和 gdf 可以被搜索到，如果是 glaf 这种则是不能被找到的
`grep -n '[0-9]' temp.txt`:搜索含有任意数字的一行，注意，在 [] 中的 - 是有特殊含义的，同时也可以使用 `grep -n [:digit:] temp.txt`来代替。而 - 中的顺序是由 ASCII 来设定的
`grep -n 'oo[^t]' temp.txt`:搜索不为 oot 的那一行
